<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>What Is the Difference Between Transaction Abort and Transaction Doom | Jürgen Gmach</title><meta name=keywords content="zope,transaction"><meta name=description content="Zope is using the transaction package to manage - you guess - transactions.
More specifically, a transaction starts when Zope receives a request, and the transaction succeeds when the action triggered by the request works out.
When the action causes an exception, the transaction will be rolled back.
This means, usually you very rarely have to interfere with the transaction management manually.
Last week I was implementing a new XML-RPC API, which basically looks like the following code:"><meta name=author content><link rel=canonical href=https://jugmac00.github.io/til/what-is-the-difference-between-transaction-abort-and-transaction-doom/><link crossorigin=anonymous href=/assets/css/stylesheet.96771a12b249af1ff464eabdaa85d1a5268a4379a9f2da62cfd409656ff0233b.css integrity="sha256-lncaErJJrx/0ZOq9qoXRpSaKQ3mp8tpiz9QJZW/wIzs=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://jugmac00.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://jugmac00.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://jugmac00.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://jugmac00.github.io/apple-touch-icon.png><link rel=mask-icon href=https://jugmac00.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="What Is the Difference Between Transaction Abort and Transaction Doom"><meta property="og:description" content="Zope is using the transaction package to manage - you guess - transactions.
More specifically, a transaction starts when Zope receives a request, and the transaction succeeds when the action triggered by the request works out.
When the action causes an exception, the transaction will be rolled back.
This means, usually you very rarely have to interfere with the transaction management manually.
Last week I was implementing a new XML-RPC API, which basically looks like the following code:"><meta property="og:type" content="article"><meta property="og:url" content="https://jugmac00.github.io/til/what-is-the-difference-between-transaction-abort-and-transaction-doom/"><meta property="article:section" content="til"><meta property="article:published_time" content="2021-02-15T13:59:42+02:00"><meta property="article:modified_time" content="2021-02-15T13:59:42+02:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="What Is the Difference Between Transaction Abort and Transaction Doom"><meta name=twitter:description content="Zope is using the transaction package to manage - you guess - transactions.
More specifically, a transaction starts when Zope receives a request, and the transaction succeeds when the action triggered by the request works out.
When the action causes an exception, the transaction will be rolled back.
This means, usually you very rarely have to interfere with the transaction management manually.
Last week I was implementing a new XML-RPC API, which basically looks like the following code:"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Today I Learned","item":"https://jugmac00.github.io/til/"},{"@type":"ListItem","position":3,"name":"What Is the Difference Between Transaction Abort and Transaction Doom","item":"https://jugmac00.github.io/til/what-is-the-difference-between-transaction-abort-and-transaction-doom/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"What Is the Difference Between Transaction Abort and Transaction Doom","name":"What Is the Difference Between Transaction Abort and Transaction Doom","description":"Zope is using the transaction package to manage - you guess - transactions.\nMore specifically, a transaction starts when Zope receives a request, and the transaction succeeds when the action triggered by the request works out.\nWhen the action causes an exception, the transaction will be rolled back.\nThis means, usually you very rarely have to interfere with the transaction management manually.\nLast week I was implementing a new XML-RPC API, which basically looks like the following code:","keywords":["zope","transaction"],"articleBody":"Zope is using the transaction package to manage - you guess - transactions.\nMore specifically, a transaction starts when Zope receives a request, and the transaction succeeds when the action triggered by the request works out.\nWhen the action causes an exception, the transaction will be rolled back.\nThis means, usually you very rarely have to interfere with the transaction management manually.\nLast week I was implementing a new XML-RPC API, which basically looks like the following code:\ndef create_company(data): try: validate(data) except ValidationError: # tell client about error else: company = _create_company(data) return company.id Now, there is a problem when the API receives invalid data.\nI cannot re-raise a ValueError, otherwise the XML-RPC client just receives a meaningless 500 internal server error.\nWhen I return an xmlrpc.client.Fault object, the client gets a meaningful error message, but the transaction succeeds. If there is any side effect, it gets committed. That is not what we want here.\ntransaction.abort() anyone? Ok. What about adding a transaction.abort() in the except block?\nThis also does not yield the desired result.\nThe changed data / side effect still gets persisted!\nWait what?\nAfter a transaction begins, the changed objects are marked to be persisted in case of a successful transaction - so far so good…\n… but the abort only removes the mark, but does not undo the changed data.\nAfter the abort Zope automatically starts a new transaction, and in case those objects from before get marked again, also the changed state from before gets persisted!\ndoom to the rescue The solution is simple (once you know it). Instead of transaction.abort() you have to use a transaction.doom() - the latter one really makes sure the transaction is rolled back.\n","wordCount":"285","inLanguage":"en","datePublished":"2021-02-15T13:59:42+02:00","dateModified":"2021-02-15T13:59:42+02:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://jugmac00.github.io/til/what-is-the-difference-between-transaction-abort-and-transaction-doom/"},"publisher":{"@type":"Organization","name":"Jürgen Gmach","logo":{"@type":"ImageObject","url":"https://jugmac00.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script><header class=header><nav class=nav><div class=logo><a href=https://jugmac00.github.io accesskey=h title="Jürgen Gmach (Alt + H)">Jürgen Gmach</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://jugmac00.github.io/about/ title=about><span>about</span></a></li><li><a href=https://jugmac00.github.io/blog/ title=blog><span>blog</span></a></li><li><a href=https://jugmac00.github.io/til/ title=til><span>today-i-learned</span></a></li><li><a href=https://jugmac00.github.io/talks/ title=talks><span>talks</span></a></li><li><a href=https://jugmac00.github.io/hiring/ title=hiring><span>hiring</span></a></li><li><a href=https://jugmac00.github.io/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>What Is the Difference Between Transaction Abort and Transaction Doom</h1><div class=post-meta><span title="2021-02-15 13:59:42 +0200 +0200">February 15, 2021</span></div></header><div class=post-content><p><strong>Zope</strong> is using the <a href=https://transaction.readthedocs.io/en/latest/index.html>transaction</a> package to manage - you guess - transactions.</p><p>More specifically, a transaction starts when Zope receives a request,
and the transaction succeeds when the action triggered by the request works out.</p><p>When the action causes an exception,
the transaction will be rolled back.</p><p>This means,
usually you very rarely have to interfere with the transaction management manually.</p><p>Last week I was implementing a new <strong>XML-RPC</strong> API,
which basically looks like the following code:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>create_company</span>(data):
  <span style=color:#66d9ef>try</span>:
      validate(data)
  <span style=color:#66d9ef>except</span> ValidationError:
      <span style=color:#75715e># tell client about error</span>
  <span style=color:#66d9ef>else</span>:
     company <span style=color:#f92672>=</span> _create_company(data)
     <span style=color:#66d9ef>return</span> company<span style=color:#f92672>.</span>id
</code></pre></div><p>Now, there is a problem when the API receives invalid data.</p><p>I cannot re-raise a ValueError,
otherwise the XML-RPC client just receives a meaningless <code>500 internal server error</code>.</p><p>When I return an <code>xmlrpc.client.Fault</code> object,
the client gets a meaningful error message,
but the <strong>transaction succeeds</strong>.
If there is any side effect, it gets committed.
That is not what we want here.</p><h2 id=transactionabort-anyone>transaction.abort() anyone?<a hidden class=anchor aria-hidden=true href=#transactionabort-anyone>#</a></h2><p>Ok. What about adding a <code>transaction.abort()</code> in the <code>except</code> block?</p><p>This also does not yield the desired result.</p><p>The changed data / side effect still gets persisted!</p><p>Wait what?</p><p>After a transaction begins,
the changed objects are marked to be persisted in case of a successful transaction - so far so good&mldr;</p><p>&mldr; but the <code>abort</code> only removes the mark, but does not undo the changed data.</p><p>After the <code>abort</code> Zope automatically starts a new transaction,
and in case those objects from before get marked again,
also the changed state from before gets persisted!</p><h2 id=doom-to-the-rescue>doom to the rescue<a hidden class=anchor aria-hidden=true href=#doom-to-the-rescue>#</a></h2><p>The solution is simple (once you know it).
Instead of <code>transaction.abort()</code> you have to use a <code>transaction.doom()</code> - the latter one really makes sure the transaction is rolled back.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://jugmac00.github.io/tags/zope/>zope</a></li><li><a href=https://jugmac00.github.io/tags/transaction/>transaction</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://jugmac00.github.io>Jürgen Gmach</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById('menu');menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script></body></html>